<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/mindar/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + TS</title>
    <link rel="stylesheet" crossorigin href="/mindar/assets/index-DHYh7RDi.css">
  </head>
  <script src="/mindar/vendor/aframe-1.5.0.min.js"></script>
  <script src="/mindar/vendor/mindar-image-1.2.2.prod.js"></script>
  <script src="/mindar/vendor/mindar-image-aframe-1.2.2.prod.js"></script>
  <script src="/mindar/vendor/hls-1.5.15.min.js"></script>

  <body>
    <div id="dev-tools" data-show-status="showing">
      <button id="dev-tools-show-hide-btn">Hide Dev Tools</button>
      <div id="notice-board-misc" class="notice-board-div">
        <ul class="notice-board">
          <li id="notice-marker-found" data-status="bad">Marker Lost</li>
          <li id="notice-fps-display">FPS: -</li>
        </ul>
      </div>
      <div id="notice-board-marker" class="notice-board-div">
        <button id="notice-board-marker-show-hide-btn" class="show-hide-btn">
          Marker
        </button>
        <ul class="notice-board" data-show-status="showing">
          <li id="notice-marker-position">Pos: -</li>
          <li id="notice-marker-rotation">Rot: -</li>
          <li id="notice-marker-scale">Scl: -</li>
        </ul>
      </div>
    </div>
    <a-scene
      id="scene"
      frame-scene
      mindar-image="imageTargetSrc: ./targets.mind;"
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: false"
    >
      <a-assets>
        <video
          id="hls-video"
          preload="metadata"
          crossorigin="anonymous"
          muted="true"
          playsinline="true"
          loop="true"
        ></video>
      </a-assets>
      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>
      <a-entity id="marker" mindar-image-target="targetIndex: 0"> </a-entity>
      <a-plane
        id="obj"
        position="1000 1000 -10"
        rotation="0 0 0"
        scale="1 1 1"
        width="1.6"
        height=".9"
        visible="true"
        material="src: #hls-video; shader: flat;"
      ></a-plane>

      <a-plane
        id="topLeft"
        position="10000 10000 10000"
        width="1"
        height="1"
        color="red"
      ></a-plane>
      <a-plane
        id="topRight"
        position="10000 10000 10000"
        width="1"
        height="1"
        color="green"
      ></a-plane>
      <a-plane
        id="bottomLeft"
        position="10000 10000 10000"
        width="1"
        height="1"
        color="blue"
      ></a-plane>
      <a-plane
        id="bottomRight"
        position="10000 10000 10000"
        width="1"
        height="1"
        color="yellow"
      ></a-plane>
    </a-scene>
  </body>
  <script>
    const video = document.querySelector("#hls-video");
    video.volume = 1;
    video.muted = true;
    const hlsUrl =
      "https://reel-em-in-hls-bucket.s3-us-west-1.amazonaws.com/bab4eed3-a93e-4dff-ae47-6a29195f2a23/playlist.m3u8";

    if (Hls.isSupported()) {
      const hls = new Hls({
        debug: false,
        enableWorker: true,
        lowLatencyMode: false,
        maxBufferLength: 10,
        maxMaxBufferLength: 20,
        maxBufferSize: 60 * 1000 * 1000,
      });

      hls.loadSource(hlsUrl);
      hls.attachMedia(video);

      hls.on(Hls.Events.ERROR, (event, data) => {
        console.error("HLS Error:", data);
      });
    } else if (video.canPlayType("application/vnd.apple.mpegurl")) {
      // Safari native HLS support
      video.src = hlsUrl;
      video.addEventListener("loadedmetadata", () => {
        video.play().catch((e) => {
          console.log("Autoplay blocked, user interaction required");
        });
      });
    }

    AFRAME.registerComponent("frame-scene", {
      init: function () {
        // Hard Coded Vals
        this.lerpRate = 0.2;
        // // Limits
        this.rotationalLimits = {
          x: {
            min: -15,
            max: 15,
          },
          y: {
            min: -15,
            max: 15,
          },
          z: {
            min: -15,
            max: 15,
          },
        };
        // Temp Vals
        // // Flags
        this.started = false;
        this.markerFound = false;
        // // Update Vals
        this.frameCount = 0;
        this.lastTime = 0;
        this.fps = 0;
        // // MindAR Transforms
        this.tmpPos = new AFRAME.THREE.Vector3();
        this.tmpQuat = new AFRAME.THREE.Quaternion();
        this.tmpScl = new AFRAME.THREE.Vector3();
        this.tmpEuler = new AFRAME.THREE.Euler();
        this.tmpRot = { x: 0, y: 0, z: 0 };
        // Corners
        this.corners = {
          topLeft: {
            x: 0,
            y: 0,
            z: 0,
            width: 0,
            height: 0,
          },
          topRight: {
            x: 0,
            y: 0,
            z: 0,
            width: 0,
            height: 0,
          },
          bottomLeft: {
            x: 0,
            y: 0,
            z: 0,
            width: 0,
            height: 0,
          },
          bottomRight: {
            x: 0,
            y: 0,
            z: 0,
            width: 0,
            height: 0,
          },
        };
        // Current Obj Data
        this.currObjData = {
          position: {
            x: 0,
            y: 0,
            z: 0,
          },
          rotation: {
            x: 0,
            y: 0,
            z: 0,
          },
          scale: {
            x: 0,
            y: 0,
            z: 0,
          },
        };
        // Goal Obj Data
        this.goalObjData = {
          position: {
            x: 0,
            y: 0,
            z: 0,
          },
          rotation: {
            x: 0,
            y: 0,
            z: 0,
          },
          scale: {
            x: 0,
            y: 0,
            z: 0,
          },
        };

        // // Misc
        this.Pi = Math.Pi;
        this.twoPi = Math.PI * 2;

        // Rendered Elements
        this.marker = document.querySelector("#marker");
        this.scene = document.querySelector("a-scene");
        this.camera = document.querySelector("a-camera");
        this.obj = document.querySelector("#obj");

        // Video
        this.video = document.querySelector("#hls-video");

        // Dev Tools
        this.devTools = document.querySelector("#dev-tools");
        this.devToolsShowHideBtn = document.querySelector(
          "#dev-tools-show-hide-btn"
        );
        this.markerShowHideBtn = document.querySelector(
          `#notice-board-marker-show-hide-btn`
        );
        this.markerNoticeBoard = document.querySelector(
          `#notice-board-marker>.notice-board`
        );
        this.noticeFpsDisplay = document.querySelector("#notice-fps-display");
        this.noticeFoundMarker = document.querySelector("#notice-marker-found");
        this.noticeMarkerPosition = document.querySelector(
          "#notice-marker-position"
        );
        this.noticeMarkerRotation = document.querySelector(
          "#notice-marker-rotation"
        );
        this.noticeMarkerScale = document.querySelector("#notice-marker-scale");

        this.topLeft = document.querySelector("#topLeft");
        this.topRight = document.querySelector("#topRight");
        this.bottomLeft = document.querySelector("#bottomLeft");
        this.bottomRight = document.querySelector("#bottomRight");

        // Register Events
        // // Click Events
        this.devToolsShowHideBtn.addEventListener("click", () => {
          const showingStatus = this.devTools.getAttribute("data-show-status");
          if (showingStatus === "showing") {
            this.devTools.setAttribute("data-show-status", "hidden");
            this.devToolsShowHideBtn.textContent = "Show Dev Tools";
          } else {
            this.devTools.setAttribute("data-show-status", "showing");
            this.devToolsShowHideBtn.textContent = "Hide Dev Tools";
          }
        });
        this.markerShowHideBtn.addEventListener("click", () => {
          const showingStatus =
            this.markerNoticeBoard.getAttribute("data-show-status");
          this.markerNoticeBoard.setAttribute(
            "data-show-status",
            showingStatus === "showing" ? "hidden" : "showing"
          );
        });
        // // AR Events
        this.scene.addEventListener("arReady", () => {
          this.syncCameraProperties();
          this.calculateScreenCorners();
        });
        // // Marker Events
        this.marker.addEventListener("targetFound", () => {
          this.updateMarkerData();
          this.markerFound = true;
          this.noticeFoundMarker.textContent = "Marker Found";
          this.noticeFoundMarker.setAttribute("data-status", "good");

          if (!this.started) {
            this.started = true;
            this.video.play();
          }
          this.goalObjData = this.genMarkerGoalObjData();
          this.currObjData = this.genMarkerGoalObjData();
          this.lerpRate = 1;
          this.updateObjData();
        });
        this.marker.addEventListener("targetLost", () => {
          console.log("Event: Target Lost");
          this.markerFound = false;
          this.noticeFoundMarker.textContent = "Marker Lost";
          this.noticeFoundMarker.setAttribute("data-status", "bad");
          this.lerpRate = 0.2;
          this.goalObjData = this.genEdgesGoalObjData();
        });

        // Camera Funcs
        this.syncCameraProperties = function () {
          if (this.camera.object3D && this.camera.object3D.children[0]) {
            const threeCamera = this.camera.object3D.children[0];

            // Update A-Frame camera to match THREE.js
            this.camera.setAttribute("camera", {
              fov: threeCamera.fov,
              near: threeCamera.near,
              far: threeCamera.far,
            });
          }
        };
        this.calculateScreenCorners = function () {
          const threeCamera = this.camera.object3D.children[0];

          const near = threeCamera.near;
          const fov = threeCamera.fov;
          const aspect = threeCamera.aspect;

          const zDistance = -near;

          const verticalHalfFOVRad = (fov / 2) * (Math.PI / 180);

          const tanResult = Math.tan(verticalHalfFOVRad);

          const halfHeight = near * tanResult;

          const halfWidth = halfHeight * aspect;
          this.corners = {
            topLeft: {
              x: -halfWidth,
              y: halfHeight,
              z: zDistance,
              width: 1,
              height: 1,
            },
            topRight: {
              x: halfWidth,
              y: halfHeight,
              z: zDistance,
              width: 1,
              height: 1,
            },
            bottomLeft: {
              x: -halfWidth,
              y: -halfHeight,
              z: zDistance,
              width: 1,
              height: 1,
            },
            bottomRight: {
              x: halfWidth,
              y: -halfHeight,
              z: zDistance,
              width: 1,
              height: 1,
            },
          };
          // Set topLeft corner plane
          this.topLeft.setAttribute(
            "position",
            `${this.corners.topLeft.x} ${this.corners.topLeft.y} ${this.corners.topLeft.z}`
          );
          this.topLeft.setAttribute("width", this.corners.topLeft.width);
          this.topLeft.setAttribute("height", this.corners.topLeft.height);

          // Set topRight corner plane
          this.topRight.setAttribute(
            "position",
            `${this.corners.topRight.x} ${this.corners.topRight.y} ${this.corners.topRight.z}`
          );
          this.topRight.setAttribute("width", this.corners.topRight.width);
          this.topRight.setAttribute("height", this.corners.topRight.height);

          // Set bottomLeft corner plane
          this.bottomLeft.setAttribute(
            "position",
            `${this.corners.bottomLeft.x} ${this.corners.bottomLeft.y} ${this.corners.bottomLeft.z}`
          );
          this.bottomLeft.setAttribute("width", this.corners.bottomLeft.width);
          this.bottomLeft.setAttribute(
            "height",
            this.corners.bottomLeft.height
          );

          // Set bottomRight corner plane
          this.bottomRight.setAttribute(
            "position",
            `${this.corners.bottomRight.x} ${this.corners.bottomRight.y} ${this.corners.bottomRight.z}`
          );
          this.bottomRight.setAttribute(
            "width",
            this.corners.bottomRight.width
          );
          this.bottomRight.setAttribute(
            "height",
            this.corners.bottomRight.height
          );
        };
        // Update Funcs
        this.updateTmpData = function () {
          if (!this.markerFound) return;
          const marker3d = marker.object3D;
          marker3d.updateMatrixWorld(true);
          marker3d.matrixWorld.decompose(
            this.tmpPos,
            this.tmpQuat,
            this.tmpScl
          );
          this.tmpEuler.setFromQuaternion(this.tmpQuat, "XYZ");
          const d = AFRAME.THREE.MathUtils.radToDeg;
          this.tmpRot = {
            x: d(this.tmpEuler.x),
            y: d(this.tmpEuler.y),
            z: d(this.tmpEuler.z),
          };
        };
        this.updateMarkerData = function () {
          if (!this.markerFound) return;

          this.goalObjData = this.genMarkerGoalObjData();

          // Position
          this.noticeMarkerPosition.textContent = `Pos: {x: ${this.tmpPos.x.toFixed(
            2
          )}, y: ${this.tmpPos.y.toFixed(2)}, z: ${this.tmpPos.z.toFixed(2)}}`;
          // Rotation
          const rotX = this.tmpRot.x.toFixed(1);
          const rotY = this.tmpRot.y.toFixed(1);
          const rotZ = this.tmpRot.z.toFixed(1);
          this.noticeMarkerRotation.textContent = `Rot: {x: ${rotX}°, y: ${rotY}°, z: ${rotZ}°}`;
          // Scale
          this.noticeMarkerScale.textContent = `Scl: {x: ${this.tmpScl.x.toFixed(
            2
          )}, y: ${this.tmpScl.y.toFixed(2)}, z: ${this.tmpScl.z.toFixed(2)}}`;
        };
        this.updateObjData = function () {
          if (!this.started || !this.obj) return;

          this.currObjData = this.calcNewCurrObjData(
            this.currObjData,
            this.goalObjData,
            this.lerpRate
          );

          this.obj.setAttribute("position", {
            x: this.currObjData.position.x,
            y: this.currObjData.position.y,
            z: this.currObjData.position.z,
          });
          this.obj.setAttribute("scale", {
            x: this.currObjData.scale.x,
            y: this.currObjData.scale.y,
            z: this.currObjData.scale.z,
          });
          this.obj.setAttribute("rotation", {
            x: this.currObjData.rotation.x,
            y: this.currObjData.rotation.y,
            z: this.currObjData.rotation.z,
          });
        };
        // Util Funcs
        this.genEdgesGoalObjData = function () {
          const topLeft = this.corners.topLeft;
          const topRight = this.corners.topRight;
          const desiredWidth = topRight.x - topLeft.x;
          const aspectRatio = 16 / 9;
          const desiredHeight = desiredWidth / aspectRatio;
          const originalWidth = 1.6;
          const originalHeight = 0.9;
          const scaleX = desiredWidth / originalWidth;
          const scaleY = desiredHeight / originalHeight;
          const scaleZ = 1;
          const centerX = (topLeft.x + topRight.x) / 2;
          const centerY = topLeft.y - desiredHeight / 2;
          const centerZ = topLeft.z;
          return {
            position: {
              x: centerX,
              y: centerY,
              z: centerZ,
            },
            rotation: {
              x: 0,
              y: 0,
              z: 0,
            },
            scale: {
              x: scaleX,
              y: scaleY,
              z: scaleZ,
            },
          };
        };
        this.genMarkerGoalObjData = function () {
          return {
            position: {
              x: this.tmpPos.x,
              y: this.tmpPos.y,
              z: this.tmpPos.z,
            },
            rotation: {
              x: clamp(
                this.tmpRot.x,
                this.rotationalLimits.x.min,
                this.rotationalLimits.x.max
              ),
              y: clamp(
                this.tmpRot.y,
                this.rotationalLimits.y.min,
                this.rotationalLimits.y.max
              ),
              z: clamp(
                this.tmpRot.z,
                this.rotationalLimits.z.min,
                this.rotationalLimits.z.max
              ),
            },
            scale: {
              x: this.tmpScl.x,
              y: this.tmpScl.y,
              z: this.tmpScl.z,
            },
          };
        };
        this.calcNewCurrObjData = function (curr, goal, lerpRate) {
          return {
            position: {
              x: lerp(curr.position.x, goal.position.x, lerpRate),
              y: lerp(curr.position.y, goal.position.y, lerpRate),
              z: lerp(curr.position.z, goal.position.z, lerpRate),
            },
            rotation: {
              x: lerp(curr.rotation.x, goal.rotation.x, lerpRate),
              y: lerp(curr.rotation.y, goal.rotation.y, lerpRate),
              z: lerp(curr.rotation.z, goal.rotation.z, lerpRate),
            },
            scale: {
              x: lerp(curr.scale.x, goal.scale.x, lerpRate),
              y: lerp(curr.scale.y, goal.scale.y, lerpRate),
              z: lerp(curr.scale.z, goal.scale.z, lerpRate),
            },
          };
        };
      },
      tick: function (time, timeDelta) {
        this.frameCount++;
        if (time - this.lastTime >= 1000) {
          this.fps = Math.round(
            (this.frameCount * 1000) / (time - this.lastTime)
          );
          this.frameCount = 0;
          this.lastTime = time;
          this.noticeFpsDisplay.textContent = `FPS: ${this.fps}`;
        }
        if (this.markerFound) {
          this.updateTmpData();
          this.updateMarkerData();
        }
        this.updateObjData();
      },
    });

    function snapPlaneToTopEdges({ plane, camera, video, distance = 1 }) {
      // Corner positions
      const topLeft = { x: -5.53, y: 2.86, z: -10 };
      const topRight = { x: 5.53, y: 2.86, z: -10 };

      // Calculate desired dimensions
      const desiredWidth = topRight.x - topLeft.x; // 11.06
      const aspectRatio = 16 / 9;
      const desiredHeight = desiredWidth / aspectRatio; // 6.22

      // Get original plane dimensions
      const originalWidth = 1.6;
      const originalHeight = 0.9;

      // Calculate scale factors
      const scaleX = desiredWidth / originalWidth; // 11.06 / 1.6 = 6.91
      const scaleY = desiredHeight / originalHeight; // 6.22 / 0.9 = 6.91
      const scaleZ = 1;

      // Position center (moved down by half the desired height)
      const centerX = (topLeft.x + topRight.x) / 2; // 0
      const centerY = topLeft.y - desiredHeight / 2; // 2.86 - 3.11 = -0.25
      const centerZ = topLeft.z; // -10

      plane.setAttribute("position", {
        x: centerX,
        y: centerY,
        z: centerZ,
      });

      plane.setAttribute("rotation", {
        x: 0,
        y: 0,
        z: 0,
      });

      plane.setAttribute("scale", {
        x: scaleX, // 6.91
        y: scaleY, // 6.91
        z: scaleZ, // 1
      });
    }

    function clamp(num, min, max) {
      return Math.min(Math.max(num, min), max);
    }
    function lerp(x, y, a) {
      return x * (1 - a) + y * a;
    }
  </script>
</html>
